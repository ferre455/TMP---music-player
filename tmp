#!/usr/bin/env python3
import curses
import os
import subprocess
import socket
import json
import time
import tempfile
import random

# ---------- CONFIGURATION ----------
MUSIC_DIR = os.path.expanduser("~/Music")
SUPPORTED = (".mp3", ".wav", ".flac", ".ogg", ".m4a")

PLAYER_PROC = None
IPC_PATH = None

def get_music_files():
    try:
        return sorted([f for f in os.listdir(MUSIC_DIR) if f.lower().endswith(SUPPORTED)])
    except:
        return []

def stop_player():
    global PLAYER_PROC, IPC_PATH
    if PLAYER_PROC:
        PLAYER_PROC.terminate()
        PLAYER_PROC = None
    if IPC_PATH and os.path.exists(IPC_PATH):
        try: os.remove(IPC_PATH)
        except: pass
    IPC_PATH = None

def start_player(filepath):
    global PLAYER_PROC, IPC_PATH
    stop_player()
    IPC_PATH = tempfile.mktemp(prefix="mpv-socket-")

    PLAYER_PROC = subprocess.Popen(
        [
            "mpv",
            f"--input-ipc-server={IPC_PATH}",
            "--geometry=300x300-20+20",
            "--autofit=300x300",
            "--ontop",
            "--force-window=immediate",
            "--title=MusicPlayer-Cover",
            filepath,
        ],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )

def mpv_command(command):
    if not IPC_PATH or not os.path.exists(IPC_PATH): return None
    try:
        with socket.socket(socket.AF_UNIX) as s:
            s.settimeout(0.05)
            s.connect(IPC_PATH)
            s.sendall((json.dumps(command) + "\n").encode())
            return json.loads(s.recv(4096).decode())
    except:
        return None

def get_property(prop):
    resp = mpv_command({"command": ["get_property", prop]})
    return resp["data"] if resp and "data" in resp else None

def draw(stdscr, files, selected, offset, time_str):
    stdscr.erase()
    h, w = stdscr.getmaxyx()
    stdscr.addstr(1, (w - 12) // 2, "Music Player", curses.A_BOLD)
    stdscr.addstr(2, 2, "─" * (w - 4))

    visible_count = h - 8
    for i in range(visible_count):
        idx = offset + i
        if idx >= len(files): break
        if idx == selected:
            stdscr.attron(curses.A_REVERSE)
            stdscr.addstr(4 + i, 2, f" > {files[idx]}"[:w-4])
            stdscr.attroff(curses.A_REVERSE)
        else:
            stdscr.addstr(4 + i, 2, f"   {files[idx]}"[:w-4])

    if time_str:
        stdscr.addstr(h - 4, 2, time_str.ljust(w - 4))
    
    footer = "↑↓ Move | Enter Play | Space Pause | s Shuffle | +/- Vol | ←→ Prev/Next | q Quit"
    stdscr.addstr(h - 2, 2, footer[:w-4], curses.A_DIM)
    stdscr.refresh()

def main(stdscr):
    curses.curs_set(0)
    curses.noecho()
    stdscr.keypad(True)
    stdscr.timeout(100)
    
    files = get_music_files()
    if not files: return

    selected = 0
    offset = 0
    is_playing = False
    last_status_check = 0
    last_start_time = 0 
    none_count = 0
    cached_time = ""

    while True:
        h, w = stdscr.getmaxyx()
        list_height = h - 8

        # Correct Scrolling logic
        if selected < offset: 
            offset = selected
        elif selected >= offset + list_height: 
            offset = selected - list_height + 1

        now = time.time()
        if now - last_status_check > 0.5:
            pos = get_property("time-pos")
            dur = get_property("duration")
            
            if pos is not None and dur is not None:
                none_count = 0
                rem = max(0, int(dur - pos))
                cached_time = f"Time remaining: -{rem//60:02}:{rem%60:02}"
            else:
                if is_playing and (now - last_start_time > 2.0):
                    none_count += 1
                    if none_count >= 3:
                        if selected < len(files) - 1:
                            selected += 1 # Move to next track automatically
                            start_player(os.path.join(MUSIC_DIR, files[selected]))
                            last_start_time = now
                            none_count = 0
                        else:
                            is_playing = False
                cached_time = ""
            last_status_check = now

        draw(stdscr, files, selected, offset, cached_time)
        
        ch = stdscr.getch()
        if ch == ord('q'): 
            break
        elif ch == curses.KEY_UP and selected > 0: 
            selected -= 1
        elif ch == curses.KEY_DOWN and selected < len(files) - 1: 
            selected += 1
        elif ch == ord('s'):
            random.shuffle(files)
            selected, offset = 0, 0
        elif ch in (10, 13): 
            start_player(os.path.join(MUSIC_DIR, files[selected]))
            is_playing, last_start_time, none_count = True, now, 0
        elif ch == ord(' '): 
            mpv_command({"command": ["cycle", "pause"]})
        elif ch == ord('+'):
            mpv_command({"command": ["add", "volume", 5]})
        elif ch == ord('-'):
            mpv_command({"command": ["add", "volume", -5]})
            
        # CORRECTED PREV/NEXT MAPPING
        elif ch == curses.KEY_RIGHT: # Next Song
            if selected < len(files) - 1:
                selected += 1
                start_player(os.path.join(MUSIC_DIR, files[selected]))
                is_playing, last_start_time, none_count = True, now, 0
        elif ch == curses.KEY_LEFT: # Previous Song
            if selected > 0:
                selected -= 1
                start_player(os.path.join(MUSIC_DIR, files[selected]))
                is_playing, last_start_time, none_count = True, now, 0
        
        time.sleep(0.01)

if __name__ == "__main__":
    try:
        curses.wrapper(main)
    finally:
        stop_player()
